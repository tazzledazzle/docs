---
title: Reusable Snippets
description: Reusable, custom snippets that have been collected
icon: 'recycle'
---

import SnippetIntro from '/snippets/snippet-intro.mdx';

<SnippetIntro />

## Code problems
<AccordionGroup>
  <Accordion title="twoSums"> 
    #### **Problem Statement:**
    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
    #### **Key Identifiers:**
      * Array of integers
      * Target sum
      * Return indices of two numbers
    #### **Pseudocode:**
   
    #### **Key Details Interviewers Look For:**
      * Understanding of hash maps for O(n) solution
      * Handling edge cases (e.g., no solution)
      * Time and space complexity analysis
  <CodeGroup>
    ```python Pseudocode
    function twoSum(nums, target):
        hashmap = {}
        for i from 0 to length(nums) - 1:
            complement = target - nums[i]
            if complement in hashmap:
                return [hashmap[complement], i]
            hashmap[nums[i]] = i
        return []
    ```
    ```cpp C++
    class Solution {
    public:
        vector<int> twoSum(vector<int>& nums, int target) {
            std::unordered_map<int, int> hashmap;
    
            for (int i = 0; i < nums.size(); ++i) {
                int complement = target - nums[i];
                if (hashmap.find(complement) != hashmap.end()) {
                    return {hashmap[complement], i};
                }
                hashmap[nums[i]] = i;
            }
            return {};
        }
    };
    ```
    </CodeGroup>
  
  </Accordion>
  <Accordion title="Best Time to Buy and Sell Stock"> 
    
    <CodeGroup>
    </CodeGroup>
  </Accordion>
  <Accordion title="Contains Duplicate"> 
    
    <CodeGroup>
    </CodeGroup>
  </Accordion>
  <Accordion title="Product of Array Except Self">
    
    <CodeGroup>
    </CodeGroup> 
  </Accordion>
  {/*
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  <Accordion title="twoSums"> 
  </Accordion>
  */}
</AccordionGroup>


# Comprehensive List of 150 Common Coding Interview Questions â€” Nov 12, 2024 at 11:39â€¯AM
# ==ðŸŸ¡Comprehensive List of 150 Common Coding Interview== Questions
> Iâ€™m not sure if these are the appropriate commons

Preparing for coding interviews can be daunting, but having a structured list of common questions can significantly enhance your readiness. Below is a comprehensive list of 150 common coding interview questions, categorized by topic. Each question includes a brief problem statement with key identifiers, pseudocode for the solution, and the key details interviewers typically look for.

## Table of Contents
1. **Arrays and Strings**
2. **Linked Lists**
3. **Stacks and Queues**
4. **Trees and Graphs**
5. **Sorting and Searching**
6. **Dynamic Programming**
7. **Recursion and Backtracking**
8. **Bit Manipulation**
9. **Mathematical Problems**
10. **System Design and Scalability**
## 1. Arrays and Strings
### 1.1 Two Sum

* **Problem Statement:**
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
* **Key Identifiers:**
  * Array of integers
  * Target sum
  * Return indices of two numbers
* **Pseudocode:**
```
function twoSum(nums, target):
    hashmap = {}
    for i from 0 to length(nums) - 1:
        complement = target - nums[i]
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[nums[i]] = i
    return []
```
* **Key Details Interviewers Look For:**
  * Understanding of hash maps for O(n) solution
  * Handling edge cases (e.g., no solution)
  * Time and space complexity analysis
### 1.2 Best Time to Buy and Sell Stock
* **Problem Statement:**
  * Given an array prices where prices[i] is the price of a given stock on day i, find the maximum profit you can achieve by making at most one transaction.
* **Key Identifiers:**
  * Array of stock prices
  * Maximize profit
  * Single transaction (buy and sell once)
* **Pseudocode:**
```
function maxProfit(prices):
    min_price = infinity
    max_profit = 0
    for price in prices:
        if price < min_price:
            min_price = price
        elif price - min_price > max_profit:
            max_profit = price - min_price
    return max_profit
```
* **Key Details Interviewers Look For:**
  * Single pass solution
  * Tracking minimum price and maximum profit
  * Edge case handling (e.g., empty array)
### 1.3 Contains Duplicate<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice, and it should return false if every element is distinct.
* **Key Identifiers:**
  * Array of integers
  * Check for duplicates
  * Return boolean
* **Pseudocode:**
```
function containsDuplicate(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return true
        seen.add(num)
    return false
```
* **Key Details Interviewers Look For:**
  * Use of appropriate data structures (e.g., hash set)
  * Time and space complexity
  * Alternative solutions (sorting)
### 1.4 Product of Array Except Self<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an array nums of n integers where n > 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].
* **Key Identifiers:**
  * Array of integers
  * Product except self
  * No division operator
* **Pseudocode:**
```
function productExceptSelf(nums):
    length = len(nums)
    output = [1] * length
    left = 1
    for i from 0 to length - 1:
        output[i] = left
        left *= nums[i]
    right = 1
    for i from length - 1 to 0:
        output[i] *= right
        right *= nums[i]
    return output
```
* **Key Details Interviewers Look For:**
  * Understanding of prefix and suffix products
  * Space optimization
  * Handling of zeroes in the array
### 1.5 Maximum Subarray<!-- {"fold":true} -->
* **Problem Statement:**
  * Find the contiguous subarray within an array (containing at least one number) which has the largest sum.
* **Key Identifiers:**
  * Array of integers
  * Contiguous subarray
  * Maximum sum
* **Pseudocode:**
```
function maxSubArray(nums):
    max_current = max_global = nums[0]
    for i from 1 to length(nums) - 1:
        max_current = max(nums[i], max_current + nums[i])
        if max_current > max_global:
            max_global = max_current
    return max_global
```
* **Key Details Interviewers Look For:**
  * Implementation of Kadaneâ€™s Algorithm
  * Understanding of dynamic programming
  * Edge case handling (e.g., all negative numbers)
### 1.6 Merge Intervals
* **Problem Statement:**
  * `Given a collection of intervals, merge all overlapping intervals.
* **Key Identifiers:**
  * List of intervals
  * Merge overlapping
  * Return list of merged intervals
* **Pseudocode:**
```
function mergeIntervals(intervals):
    if intervals is empty:
        return []
    sort intervals based on start time
    merged = [intervals[0]]
    for i from 1 to length(intervals) - 1:
        last = merged[-1]
        current = intervals[i]
        if current.start <= last.end:
            last.end = max(last.end, current.end)
        else:
            merged.append(current)
    return merged
```
* **Key Details Interviewers Look For:**
  * Sorting intervals
  * Correctly merging overlapping intervals
  * Time complexity analysis
### 1.7 Search in Rotated Sorted Array<!-- {"fold":true} -->
* **Problem Statement:**
  * Suppose an array sorted in ascending order is rotated at some pivot. Search for a target value in the array and return its index. If not found, return -1.
* **Key Identifiers:**
  * Rotated sorted array
  * Binary search
  * Return index or -1
* **Pseudocode:**
```
function searchRotatedArray(nums, target):
    left = 0
    right = len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```
* **Key Details Interviewers Look For:**
  * Modification of binary search for rotated arrays
  * Identifying sorted halves
  * Handling duplicates (if applicable)
### 1.8 Longest Consecutive Sequence<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
* **Key Identifiers:**
  * Unsorted array
  * Longest consecutive sequence
  * Return length
* **Pseudocode:**
```
function longestConsecutive(nums):
    num_set = set(nums)
    max_length = 0
    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_length = 1
            while current_num + 1 in num_set:
                current_num += 1
                current_length += 1
            max_length = max(max_length, current_length)
    return max_length
```
* **Key Details Interviewers Look For:**
  * Use of hash sets for O(n) solution
  * Avoiding unnecessary computations
  * Edge case handling (e.g., empty array)
### 1.9 3Sum<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
* **Key Identifiers:**
  * Array of integers
  * Three numbers sum to zero
  * Return unique triplets
* **Pseudocode:**
```
function threeSum(nums):
    nums.sort()
    triplets = []
    for i from 0 to len(nums) - 3:
        if i > 0 and nums[i] == nums[i-1]:
            continue
        left = i + 1
        right = len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                triplets.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    return triplets
```
* **Key Details Interviewers Look For:**
  * Sorting to manage duplicates and use two pointers
  * Time complexity considerations
  * Ensuring uniqueness of triplets
### 1.10 Rotate Image<!-- {"fold":true} -->
* **Problem Statement:**
* You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Do this in-place.
* **Key Identifiers:**
  * n x n matrix
  * Rotate 90 degrees clockwise
  * In-place rotation
* **Pseudocode:**
```
function rotateImage(matrix):
    n = len(matrix)
    # Transpose the matrix
    for i from 0 to n - 1:
        for j from i + 1 to n - 1:
            swap(matrix[i][j], matrix[j][i])
    # Reverse each row
    for i from 0 to n - 1:
        reverse(matrix[i])

```
* **Key Details Interviewers Look For:**
  * Understanding of matrix transpose and row reversal
  * In-place manipulation
  * Space and time complexity
### 1.11 Set Matrix Zeroes<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.
* **Key Identifiers:**
  * m x n matrix
  * Set row and column to zero
  * In-place without using extra space
* **Pseudocode:**
```
function setMatrixZeroes(matrix):
    m = len(matrix)
    n = len(matrix[0])
    row_zero = false
    col_zero = false
    # Check first row and column
    for i from 0 to m - 1:
        if matrix[i][0] == 0:
            col_zero = true
            break
    for j from 0 to n - 1:
        if matrix[0][j] == 0:
            row_zero = true
            break
    # Use first row and column as markers
    for i from 1 to m - 1:
        for j from 1 to n - 1:
            if matrix[i][j] == 0:
                matrix[i][0] = 0
                matrix[0][j] = 0
    # Set matrix cells to zero based on markers
    for i from 1 to m - 1:
        if matrix[i][0] == 0:
            for j from 1 to n - 1:
                matrix[i][j] = 0
    for j from 1 to n - 1:
        if matrix[0][j] == 0:
            for i from 1 to m - 1:
                matrix[i][j] = 0
    # Finally, set first row and column to zero if needed
    if row_zero:
        for j from 0 to n - 1:
            matrix[0][j] = 0
    if col_zero:
        for i from 0 to m - 1:
            matrix[i][0] = 0
```
* **Key Details Interviewers Look For:**
  * Efficient use of space by leveraging matrix markers
  * Handling edge cases (first row and column)
  * In-place modification without additional storage
### 1.12 Valid Anagram<!-- {"fold":true} -->
* **Problem Statement:**
  * Given two strings s and t, write a function to determine if t is an anagram of s.
* **Key Identifiers:**
  * Two strings
  * Anagram check
  * Return boolean
* **Pseudocode:**
```
function isAnagram(s, t):
    if len(s) != len(t):
        return false
    count = {}
    for char in s:
        count[char] = count.get(char, 0) + 1
    for char in t:
        if char not in count or count[char] == 0:
            return false
        count[char] -= 1
    return true
```
* **Key Details Interviewers Look For:**
  * Use of hash maps or character counting
  * Handling of different character cases
  * Time and space complexity
### 1.13 Longest Substring Without Repeating Characters
* **Problem Statement:**
  * Given a string, find the length of the longest substring without repeating characters.
* **Key Identifiers:**
  * String input
  * Longest substring
  * No repeating characters
* **Pseudocode:**
```
function lengthOfLongestSubstring(s):
    char_map = {}
    left = 0
    max_length = 0
    for right from 0 to len(s) - 1:
        if s[right] in char_map and char_map[s[right]] >= left:
            left = char_map[s[right]] + 1
        char_map[s[right]] = right
        max_length = max(max_length, right - left + 1)
    return max_length
```
* **Key Details Interviewers Look For:**
  * Sliding window technique
  * Efficiently updating pointers
  * Managing character indices
### 1.14 Group Anagrams
* **Problem Statement:**
  * Given an array of strings, group the anagrams together.
* **Key Identifiers:**
  * Array of strings
  * Group anagrams
  * Return list of groups
* **Pseudocode:**
```
function groupAnagrams(strs):
    groups = {}
    for s in strs:
        key = sort(s)
        if key not in groups:
            groups[key] = []
        groups[key].append(s)
    return list(groups.values())
```
* **Key Details Interviewers Look For:**
  * Efficiently grouping using sorted strings as keys
  * Alternative methods (e.g., character count as key)
  * Time and space complexity
### 1.15 Container With Most Water
* **Problem Statement:**
  * Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai), find two lines that together with the x-axis form a container that holds the most water.
* **Key Identifiers:**
  * Array of heights
  * Maximize area formed by two lines
  * Return maximum water
* **Pseudocode:**
```
function maxArea(height):
    left = 0
    right = len(height) - 1
    max_area = 0
    while left < right:
        width = right - left
        current_area = min(height[left], height[right]) * width
        max_area = max(max_area, current_area)
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```
* **Key Details Interviewers Look For:**
  * Two-pointer approach
  * Greedy strategy to maximize area
  * Understanding why moving the shorter line is optimal
----
## 2. Linked Lists
### 2.1 Reverse a Linked List<!-- {"fold":true} -->
* **Problem Statement:**
  * Reverse a singly linked list.
* **Key Identifiers:**
  * Singly linked list
  * Reverse pointers
  * Return new head
* **Pseudocode:**
```
function reverseList(head):
    prev = null
    current = head
    while current is not null:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    return prev
```
* **Key Details Interviewers Look For:**
  * Iterative vs. recursive approaches
  * Handling edge cases (empty list, single node)
  * In-place reversal without extra space
### 2.2 Detect Cycle in a Linked List<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a linked list, determine if it has a cycle in it.
* **Key Identifiers:**
  * Linked list with possible cycle
  * Detect cycle
  * Return boolean
* **Pseudocode:**
```
function hasCycle(head):
    slow = head
    fast = head
    while fast is not null and fast.next is not null:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return true
    return false
```
* **Key Details Interviewers Look For:**
  * Floydâ€™s Tortoise and Hare algorithm
  * Understanding of two-pointer technique
  * Time and space efficiency
### 2.3 Merge Two Sorted Lists<!-- {"fold":true} -->
* **Problem Statement:**
  * Merge two sorted linked lists and return it as a new sorted list.
* **Key Identifiers:**
  * Two sorted linked lists
  * Merge into one sorted list
  * Return new head
* **Pseudocode:**
```
function mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    tail = dummy
    while l1 is not null and l2 is not null:
        if l1.val < l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next
    tail.next = l1 if l1 is not null else l2
    return dummy.next
```
* **Key Details Interviewers Look For:**
  * Iterative vs. recursive merging
  * Handling of edge cases (e.g., one list empty)
  * Maintaining sorted order
### 2.4 Remove Nth Node From End of List<!-- {"fold":true} -->
* **Problem Statement:**
  * Given the head of a linked list, remove the nth node from the end of the list and return its head.
* **Key Identifiers:**
  * Linked list
  * Remove nth node from end
  * Return modified list head
* **Pseudocode:**
```
function removeNthFromEnd(head, n):
    dummy = ListNode(0)
    dummy.next = head
    first = dummy
    second = dummy
    for i from 0 to n:
        first = first.next
    while first is not null:
        first = first.next
        second = second.next
    second.next = second.next.next
    return dummy.next
```
* **Key Details Interviewers Look For:**
  * Two-pointer technique
  * Use of dummy node to simplify edge cases
  * Correctly identifying the node to remove
### 2.5 Linked List Cycle II<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
* **Key Identifiers:**
  * Linked list with cycle
  * Identify cycle start node
  * Return node or null
* **Pseudocode:**
```
function detectCycle(head):
    slow = head
    fast = head
    has_cycle = false
    while fast is not null and fast.next is not null:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            has_cycle = true
            break
    if not has_cycle:
        return null
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    return slow
```
* **Key Details Interviewers Look For:**
  * Floydâ€™s algorithm to detect cycle
  * Resetting pointers to find cycle start
  * Time and space efficiency
### 2.6 Intersection of Two Linked Lists<!-- {"fold":true} -->
* **Problem Statement:**
  * Find the node at which the intersection of two singly linked lists begins.
* **Key Identifiers:**
  * Two linked lists
  * Intersection node
  * Return node or null
* **Pseudocode:**
```
function getIntersectionNode(headA, headB):
    if headA is null or headB is null:
        return null
    pointerA = headA
    pointerB = headB
    while pointerA != pointerB:
        pointerA = pointerA.next if pointerA is not null else headB
        pointerB = pointerB.next if pointerB is not null else headA
    return pointerA
```
* **Key Details Interviewers Look For:**
  * Handling different list lengths
  * Using two pointers to traverse lists
  * Time and space complexity
### 2.7 Remove Linked List Elements<!-- {"fold":true} -->
* **Problem Statement:**
  * Remove all elements from a linked list of integers that have value val.
* **Key Identifiers:**
  * Linked list
  * Remove nodes with specific value
  * Return modified list head
* **Pseudocode:**
```
function removeElements(head, val):
    dummy = ListNode(0)
    dummy.next = head
    current = dummy
    while current.next is not null:
        if current.next.val == val:
            current.next = current.next.next
        else:
            current = current.next
    return dummy.next
```
* **Key Details Interviewers Look For:**
  * Use of dummy node to handle head removal
  * Iterative traversal
  * Correctly updating pointers
### 2.8 Palindrome Linked List
* **Problem Statement:**
  * Determine whether a linked list is a palindrome.
* **Key Identifiers:**
  * Linked list
  * Palindrome check
  * Return boolean
* **Pseudocode:**
```
function isPalindrome(head):
    slow = fast = head
    stack = []
    while fast is not null and fast.next is not null:
        stack.append(slow.val)
        slow = slow.next
        fast = fast.next.next
    if fast is not null:
        slow = slow.next
    while slow is not null:
        top = stack.pop()
        if top != slow.val:
            return false
        slow = slow.next
    return true
```
* **Key Details Interviewers Look For:**
  * Finding the middle of the list
  * Using stack for comparison
  * Alternative methods (reversing second half)
### 2.9 Add Two Numbers<!-- {"fold":true} -->
* **Problem Statement:**
  * You are given two non-empty linked lists representing two non-negative integers. Add the two numbers and return the sum as a linked list.
* **Key Identifiers:**
  * Two linked lists
  * Each node contains a single digit
  * Return sum as linked list
* **Pseudocode:**
```
function addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0
    while l1 is not null or l2 is not null or carry:
        val1 = l1.val if l1 is not null else 0
        val2 = l2.val if l2 is not null else 0
        total = val1 + val2 + carry
        carry = total // 10
        current.next = ListNode(total % 10)
        current = current.next
        if l1 is not null:
            l1 = l1.next
        if l2 is not null:
            l2 = l2.next
    return dummy.next
```
* **Key Details Interviewers Look For:**
  * Handling different list lengths
  * Managing carry-over during addition
  * Creating new nodes correctly
### 2.10 Copy List with Random Pointer<!-- {"fold":true} -->
* **Problem Statement:**
  * A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list.
* **Key Identifiers:**
  * Linked list with random pointers
  * Deep copy
  * Return new head
* **Pseudocode:**
```
function copyRandomList(head):
    if head is null:
        return null
    # Step 1: Create copied nodes and interleave them with original nodes
    current = head
    while current is not null:
        copy = ListNode(current.val)
        copy.next = current.next
        current.next = copy
        current = copy.next
    # Step 2: Assign random pointers for the copied nodes
    current = head
    while current is not null:
        if current.random is not null:
            current.next.random = current.random.next
        current = current.next.next
    # Step 3: Restore the original list and extract the copied list
    current = head
    copy_head = head.next
    while current is not null:
        copy = current.next
        current.next = copy.next
        copy.next = copy.next.next if copy.next is not null else null
        current = current.next
    return copy_head
```
* **Key Details Interviewers Look For:**
  * Handling of random pointers
  * Efficiently creating deep copies without extra space
  * Maintaining original list structure
### 2.11 Remove Duplicates from Sorted List<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a sorted linked list, delete all duplicates such that each element appears only once.
* **Key Identifiers:**
  * Sorted linked list
  * Remove duplicates
  * Return modified list head
* **Pseudocode:**
```
function deleteDuplicates(head):
  current = head
  while current is not null and current.next is not null:
  if current.val == current.next.val:
  current.next = current.next.next
  else:
  current = current.next
  return head
```
* **Key Details Interviewers Look For:**
  * Traversing sorted list to identify duplicates
  * In-place modification
  * Handling edge cases (e.g., empty list)
### 2.12 Intersection of Two Linked Lists (with cycles)<!-- {"fold":true} -->
* **Problem Statement:**
  * Given two linked lists that may contain cycles, determine if they intersect and return the intersecting node.
* **Key Identifiers:**
  * Two linked lists with possible cycles
  * Find intersection node
  * Return node or null
* **Pseudocode:**
```
function getIntersectionNodeWithCycles(headA, headB):
    # Detect cycles in both lists
    cycleA = detectCycle(headA)
    cycleB = detectCycle(headB)
    if not cycleA and not cycleB:
        return getIntersectionNode(headA, headB)
    if (cycleA and not cycleB) or (not cycleA and cycleB):
        return null
    # Both lists have cycles
    ptr = cycleA
    while True:
        if ptr == cycleB:
            break
        ptr = ptr.next
        if ptr == cycleA:
            return null
    # Find intersection before cycle starts
    ptr1 = headA
    ptr2 = headB
    while ptr1 != ptr2:
        ptr1 = ptr1.next if ptr1 else headB
        ptr2 = ptr2.next if ptr2 else headA
    return ptr1
```
* **Key Details Interviewers Look For:**
  * Handling lists with and without cycles
  * Extending basic intersection logic
  * Ensuring no infinite loops
----
## 3. Stacks and Queues
### 3.1 Valid Parentheses<!-- {"fold":true} -->

* **Problem Statement:**
  * Given a string containing just the characters (, ), {, }, [ and ], determine if the input string is valid.
* **Key Identifiers:**
  * String of parentheses
  * Check for validity
  * Return boolean
* **Pseudocode:**
```
function isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping:
            top = stack.pop() if stack else '#'
            if mapping[char] != top:
                return false
        else:
            stack.append(char)
    return not stack
```

* **Key Details Interviewers Look For:**
  * Use of stack data structure
  * Matching opening and closing brackets
  * Handling edge cases (e.g., empty string)

### 3.2 Min Stack<!-- {"fold":true} -->

* **Problem Statement:**
  * Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
* **Key Identifiers:**
  * Stack operations
  * Retrieve minimum in O(1)
  * Design data structure
* **Pseudocode:**
```
class MinStack:
    def __init__():
        stack = []
        min_stack = []
    
    def push(x):
        stack.append(x)
        if not min_stack or x <= min_stack[-1]:
            min_stack.append(x)
    
    def pop():
        if stack.pop() == min_stack[-1]:
            min_stack.pop()
    
    def top():
        return stack[-1]
    
    def getMin():
        return min_stack[-1]
```

* **Key Details Interviewers Look For:**
  * Auxiliary stack to track minimums
  * Ensuring all operations are O(1)
  * Edge case handling (e.g., empty stack)

### 3.3 Implement Queue using Stacks<!-- {"fold":true} -->

* **Problem Statement:**
  * Implement a first in first out (FIFO) queue using only two stacks.
* **Key Identifiers:**
  * Queue operations (enqueue, dequeue)
  * Use two stacks
  * Maintain FIFO order
* **Pseudocode:**
```
class MyQueue:
    def __init__():
        stack_in = []
        stack_out = []
    
    def push(x):
        stack_in.append(x)
    
    def pop():
        if not stack_out:
            while stack_in:
                stack_out.append(stack_in.pop())
        return stack_out.pop()
    
    def peek():
        if not stack_out:
            while stack_in:
                stack_out.append(stack_in.pop())
        return stack_out[-1]
    
    def empty():
        return not stack_in and not stack_out

```
* **Key Details Interviewers Look For:**
  * Transfer elements between stacks to maintain order
  * Amortized time complexity
  * Correct handling of empty states

### 3.4 Evaluate Reverse Polish Notation<!-- {"fold":true} -->
* **Problem Statement:**
  * Evaluate the value of an arithmetic expression in Reverse Polish Notation.
* **Key Identifiers:**
  * Reverse Polish Notation (RPN)
  * Arithmetic operations
  * Return integer result
* **Pseudocode:**
```
function evalRPN(tokens):
    stack = []
    operators = {'+', '-', '*', '/'}
    for token in tokens:
        if token not in operators:
            stack.append(int(token))
        else:
            b = stack.pop()
            a = stack.pop()
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            elif token == '/':
                stack.append(int(a / b))  # Truncate towards zero
    return stack.pop()
```

* **Key Details Interviewers Look For:**
  * Use of stack for evaluation
  * Handling division truncation
  * Correct operation order

### 3.5 Daily Temperatures<!-- {"fold":true} -->

* **Problem Statement:**
  * Given a list of daily temperatures, return a list such that for each day, it tells you how many days you would have to wait until a warmer temperature.
* **Key Identifiers:**
  * Array of temperatures
  * Days to wait for warmer temp
  * Return list of integers
* **Pseudocode:**
```
function dailyTemperatures(T):
    n = len(T)
    answer = [0] * n
    stack = []
    for i from 0 to n - 1:
        while stack and T[i] > T[stack[-1]]:
            prev_index = stack.pop()
            answer[prev_index] = i - prev_index
        stack.append(i)
    return answer

```
* **Key Details Interviewers Look For:**
  * Monotonic stack usage
  * Efficient traversal
  * Handling of no warmer days

### 3.6 Largest Rectangle in Histogram<!-- {"fold":true} -->

* **Problem Statement:**
  * Given an array of integers representing the histogramâ€™s bar height where the width of each bar is 1, find the area of the largest rectangle in the histogram.
* **Key Identifiers:**
  * Histogram bar heights
  * Largest rectangle area
  * Return integer area
* **Pseudocode:**
```
function largestRectangleArea(heights):
    stack = []
    max_area = 0
    heights.append(0)
    for i from 0 to len(heights):
        while stack and heights[i] < heights[stack[-1]]:
            h = heights[stack.pop()]
            w = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, h * w)
        stack.append(i)
    return max_area
```

* **Key Details Interviewers Look For:**
  * Use of stack to track indices
  * Handling of increasing and decreasing heights
  * Correct calculation of area

### 3.7 Implement Stack with O(1) Time for Push, Pop, and GetMin<!-- {"fold":true} -->

* **Problem Statement:**
  * Design a stack that supports push, pop, and retrieving the minimum element in constant time.
* **Key Identifiers:**
  * Stack operations
  * Retrieve minimum in O(1)
  * Design data structure
* **Pseudocode:**
```
class MinStack:
    def __init__():
        stack = []
        min_stack = []
    
    def push(x):
        stack.append(x)
        if not min_stack or x <= min_stack[-1]:
            min_stack.append(x)
    
    def pop():
        if stack.pop() == min_stack[-1]:
            min_stack.pop()
    
    def top():
        return stack[-1]
    
    def getMin():
        return min_stack[-1]
```

* **Key Details Interviewers Look For:**
  * Auxiliary stack for tracking minimums
  * Ensuring all operations are O(1)
  * Edge case handling

### 3.8 Simplify Path<!-- {"fold":true} -->

* **Problem Statement:**
  * Given a string path, which is an absolute path for a file in Unix-style, simplify it.
* **Key Identifiers:**
  * Unix-style file path
  * Simplify path
  * Return canonical path
* **Pseudocode:**
```
function simplifyPath(path):
    stack = []
    components = path.split('/')
    for component in components:
        if component == '..':
            if stack:
                stack.pop()
        elif component == '.' or component == '':
            continue
        else:
            stack.append(component)
    return '/' + '/'.join(stack)
```
* **Key Details Interviewers Look For:**
  * Handling of â€˜.â€™, â€˜..â€™, and multiple slashes
  * Use of stack to manage path components
  * Edge case handling (e.g., root directory)

### 3.9 Valid Stack Sequence<!-- {"fold":true} -->

* **Problem Statement:**
  * Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.
* **Key Identifiers:**
  * Two sequences (push and pop)
  * Validate stack operations
  * Return boolean
* **Pseudocode:**
```
function validateStackSequences(pushed, popped):
    stack = []
    j = 0
    for x in pushed:
        stack.append(x)
        while stack and stack[-1] == popped[j]:
            stack.pop()
            j += 1
    return not stack
```
* **Key Details Interviewers Look For:**
  * Simulating stack operations
  * Ensuring the pop sequence is achievable
  * Time and space efficiency

### 3.10 Implement Queue using Deque<!-- {"fold":true} -->
* **Problem Statement:**
  * Implement a double-ended queue (deque) supporting push and pop operations from both ends.
* **Key Identifiers:**
  * Double-ended queue
  * Push and pop from both ends
  * Design data structure
* **Pseudocode:**
```
class Deque:
    def __init__():
        deque = []
    
    def pushFront(x):
        deque.insert(0, x)
    
    def pushBack(x):
        deque.append(x)
    
    def popFront():
        return deque.pop(0) if deque else null
    
    def popBack():
        return deque.pop() if deque else null
    
    def isEmpty():
        return len(deque) == 0
```
* **Key Details Interviewers Look For:**
  * Understanding of deque operations
  * Efficient implementation using built-in structures
  * Handling of empty deque scenarios
-----
## 4. Trees and Graphs
### 4.1 Binary Tree Inorder Traversal<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a binary tree, return the inorder traversal of its nodesâ€™ values.
* **Key Identifiers:**
  * Binary tree
  * Inorder traversal
  * Return list of values
* **Pseudocode:**
```
function inorderTraversal(root):
    result = []
    stack = []
    current = root
    while current is not null or stack:
        while current is not null:
            stack.append(current)
            current = current.left
        current = stack.pop()
        result.append(current.val)
        current = current.right
    return result
```
* **Key Details Interviewers Look For:**
  * Iterative vs. recursive traversal
  * Correct order of left, root, right
  * Handling of null nodes
### 4.2 Maximum Depth of Binary Tree<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a binary tree, find its maximum depth.
* **Key Identifiers:**
  * Binary tree
  * Maximum depth
  * Return integer depth
* **Pseudocode:**
```
function maxDepth(root):
    if root is null:
        return 0
    left_depth = maxDepth(root.left)
    right_depth = maxDepth(root.right)
    return max(left_depth, right_depth) + 1
```

* **Key Details Interviewers Look For:**
  * Recursive depth-first search
  * Alternative iterative solutions (BFS)
  * Correct base cases

### 4.3 Binary Tree Level Order Traversal<!-- {"fold":true} -->
* **Problem Statement:**
  * Return the level order traversal of a binary treeâ€™s nodesâ€™ values.
* **Key Identifiers:**
  * Binary tree
  * Level order traversal
  * Return list of levels
* **Pseudocode:**
```
function levelOrder(root):
    if root is null:
        return []
    result = []
    queue = [root]
    while queue:
        level_size = len(queue)
        level = []
        for i from 0 to level_size - 1:
            node = queue.pop(0)
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)
    return result
```

* **Key Details Interviewers Look For:**
  * Use of queue for BFS
  * Correct grouping of nodes by level
  * Handling empty trees

### 4.4 Validate Binary Search Tree<!-- {"fold":true} -->
* **Problem Statement:**
  * Determine if a given binary tree is a valid binary search tree (BST).
* **Key Identifiers:**
  * Binary tree
  * Binary search tree properties
  * Return boolean
* **Pseudocode:**
```
function isValidBST(root, min = -infinity, max = infinity):
    if root is null:
        return true
    if root.val <= min or root.val >= max:
        return false
    return isValidBST(root.left, min, root.val) and isValidBST(root.right, root.val, max)
```
* **Key Details Interviewers Look For:**
  * Understanding of BST properties
  * Recursive range validation
  * Handling of edge cases
### 4.5 Symmetric Tree<!-- {"fold":true} -->
* **Problem Statement:**
  * Check whether a binary tree is symmetric around its center.
* **Key Identifiers:**
  * Binary tree
  * Symmetric around center
  * Return boolean
* **Pseudocode:**
```
function isSymmetric(root):
    if root is null:
        return true
    return isMirror(root.left, root.right)

function isMirror(left, right):
    if left is null and right is null:
        return true
    if left is null or right is null:
        return false
    if left.val != right.val:
        return false
    return isMirror(left.left, right.right) and isMirror(left.right, right.left)
```
* **Key Details Interviewers Look For:**
  * Recursive symmetry check
  * Alternative iterative solutions using queues
  * Handling of null nodes
### 4.6 Binary Tree Zigzag Level Order Traversal
* **Problem Statement:**
  * Return the zigzag level order traversal of a binary treeâ€™s nodesâ€™ values.
* **Key Identifiers:**
  * Binary tree
  * Zigzag traversal (left to right, then right to left)
  * Return list of levels
  * **Pseudocode:**
```
function zigzagLevelOrder(root):
    if root is null:
        return []
    result = []
    queue = [root]
    left_to_right = true
    while queue:
        level_size = len(queue)
        level = []
        for i from 0 to level_size - 1:
            node = queue.pop(0)
            if left_to_right:
                level.append(node.val)
            else:
                level.insert(0, node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)
        left_to_right = not left_to_right
    return result
```
* **Key Details Interviewers Look For:**
  * Alternating the insertion order
  * Efficient traversal using BFS
  * Managing traversal direction flag
### 4.7 Construct Binary Tree from Preorder and Inorder Traversal<!-- {"fold":true} -->
* **Problem Statement:**
  * Given preorder and inorder traversal of a tree, construct the binary tree.
* **Key Identifiers:**
  * Preorder and inorder arrays
  * Reconstruct binary tree
  * Return tree root
  * **Pseudocode:**
```
function buildTree(preorder, inorder):
    if not preorder or not inorder:
        return null
    root_val = preorder[0]
    root = TreeNode(root_val)
    mid = inorder.index(root_val)
    root.left = buildTree(preorder[1:mid+1], inorder[0:mid])
    root.right = buildTree(preorder[mid+1:], inorder[mid+1:])
    return root
```
* **Key Details Interviewers Look For:**
  * Recursive tree construction
  * Handling of index boundaries
  * Optimization using hash maps for inorder indices
### 4.8 Lowest Common Ancestor of a Binary Tree<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
* **Key Identifiers:**
  * Binary tree
  * Two nodes
  * Find LCA node
* **Pseudocode:**
```
function lowestCommonAncestor(root, p, q):
    if root is null or root == p or root == q:
        return root
    left = lowestCommonAncestor(root.left, p, q)
    right = lowestCommonAncestor(root.right, p, q)
    if left and right:
        return root
    return left if left else right
```
* **Key Details Interviewers Look For:**
  * Recursive traversal
  * Identifying the split point for LCA
  * Handling cases where one node is ancestor of the other

### 4.9 Serialize and Deserialize Binary Tree<!-- {"fold":true} -->
* **Problem Statement:**
  * Design an algorithm to serialize and deserialize a binary tree.
* **Key Identifiers:**
  * Binary tree
  * Serialize to string
  * Deserialize back to tree
* **Pseudocode:**
```
class Codec:
    def serialize(root):
        vals = []
        def preorder(node):
            if node is null:
                vals.append('#')
                return
            vals.append(str(node.val))
            preorder(node.left)
            preorder(node.right)
        preorder(root)
        return ','.join(vals)
    
    def deserialize(data):
        vals = iter(data.split(','))
        def build():
            val = next(vals)
            if val == '#':
                return null
            node = TreeNode(int(val))
            node.left = build()
            node.right = build()
            return node
        return build()
```
* **Key Details Interviewers Look For:**
  * Choice of traversal method (preorder, inorder, etc.)
  * Handling null nodes
  * Ensuring accurate reconstruction
### 4.10 Binary Tree Right Side View<!-- {"fold":true} -->
* **Problem Statement:**
* Given a binary tree, imagine yourself standing on the right side and return the values of the nodes you can see ordered from top to bottom.
* **Key Identifiers:**
  * Binary tree
  * Right side view
  * Return list of visible node values
* **Pseudocode:**
```
function rightSideView(root):
    if root is null:
        return []
    result = []
    queue = [root]
    while queue:
        level_size = len(queue)
        for i from 0 to level_size - 1:
            node = queue.pop(0)
            if i == level_size - 1:
                result.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
    return result
```
* **Key Details Interviewers Look For:**
  * BFS traversal
  * Capturing the last node at each level
  * Efficient use of queues
----
## 5. Sorting and Searching<!-- {"fold":true} -->
### 5.1 Merge Sort<!-- {"fold":true} -->
* **Problem Statement:**
  * Implement the merge sort algorithm on an array of integers.
* **Key Identifiers:**
  * Array of integers
  * Implement merge sort
  * Return sorted array
* **Pseudocode:**
```
function mergeSort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = mergeSort(arr[:mid])
    right = mergeSort(arr[mid:])
    return merge(left, right)

function merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```
* **Key Details Interviewers Look For:**
  * Divide and conquer approach
  * Correct merging of sorted halves
  * Time and space complexity

### 5.2 Quick Sort<!-- {"fold":true} -->
* **Problem Statement:**
  * Implement the quick sort algorithm on an array of integers.
* **Key Identifiers:**
  * Array of integers
  * Implement quick sort
  * Return sorted array
* **Pseudocode:**
```
function quickSort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quickSort(left) + middle + quickSort(right)
```
* **Key Details Interviewers Look For:**
  * Choosing a pivot
  * Partitioning the array
  * Recursive sorting of partitions

### 5.3 Binary Search<!-- {"fold":true} -->
* **Problem Statement:**
  * Implement binary search on a sorted array of integers to find a target value.
* **Key Identifiers:**
  * Sorted array
  * Binary search
  * Return index or -1
* **Pseudocode:**
```
function binarySearch(arr, target):
    left = 0
    right = len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```
* **Key Details Interviewers Look For:**
  * Correct calculation of mid to avoid overflow
  * Iterative vs. recursive approaches
  * Handling of edge cases (e.g., empty array)
### 5.4 Search in Rotated Sorted Array<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a rotated sorted array, search for a target value and return its index. If not found, return -1.
* **Key Identifiers:**
  * Rotated sorted array
  * Binary search modification
  * Return index or -1
* **Pseudocode:**
```
function searchRotatedArray(nums, target):
    left = 0
    right = len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```
* **Key Details Interviewers Look For:**
  * Identifying sorted half
  * Adjusting search boundaries accordingly
  * Time and space complexity analysis
### 5.5 Find First and Last Position of Element in Sorted Array<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.
* **Key Identifiers:**
  * Sorted array
  * Target value
  * Return first and last indices
* **Pseudocode:**
```
function searchRange(nums, target):
    return [findFirst(nums, target), findLast(nums, target)]

function findFirst(nums, target):
    left = 0
    right = len(nums) - 1
    first = -1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            first = mid
            right = mid - 1
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return first

function findLast(nums, target):
    left = 0
    right = len(nums) - 1
    last = -1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            last = mid
            left = mid + 1
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return last
```
* **Key Details Interviewers Look For:**
  * Performing two separate binary searches
  * Ensuring first and last positions are correctly identified
  * Handling cases where target is not present
### 5.6 Kth Largest Element in an Array<!-- {"fold":true} -->
* **Problem Statement:**
  * Find the kth largest element in an unsorted array.
* **Key Identifiers:**
  * Unsorted array
  * Kth largest element
  * Return integer value
* **Pseudocode:**
```
function findKthLargest(nums, k):
    heap = []
    for num in nums:
        heap.append(num)
        heapify(heap, len(heap))
        if len(heap) > k:
            heap.pop(0)
    return heap[0]

function heapify(heap, size):
    # Implement min-heap operations
    pass
```
*Note: Typically implemented using a min-heap of size k for efficiency.*
* **Key Details Interviewers Look For:**
  * Use of heap data structure
  * Time complexity considerations (O(n log k))
  * Alternative solutions (quickselect)

### 5.7 Top K Frequent Elements<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a non-empty array of integers, return the k most frequent elements.
* **Key Identifiers:**
  * Array of integers
  * Top k frequent elements
  * Return list of integers
* **Pseudocode:**
```
function topKFrequent(nums, k):
    frequency = {}
    for num in nums:
        frequency[num] = frequency.get(num, 0) + 1
    heap = []
    for num, freq in frequency.items():
        heap.append((freq, num))
        heapify(heap, len(heap))
        if len(heap) > k:
            heap.pop(0)
    result = []
    while heap:
        result.append(heap.pop(0)[1])
    return result
```
*Note: Typically implemented using a min-heap or bucket sort for better efficiency.*
* **Key Details Interviewers Look For:**
  * Frequency counting using hash maps
  * Efficient retrieval of top k elements
  * Time and space optimization
### 5.8 Search a 2D Matrix<!-- {"fold":true} -->
* **Problem Statement:**
  * Write an efficient algorithm that searches for a value in an m x n matrix.
* **Key Identifiers:**
  * 2D matrix
  * Sorted properties (rows and columns)
  * Return boolean or indices
* **Pseudocode:**
```
function searchMatrix(matrix, target):
    if not matrix or not matrix[0]:
        return false
    m = len(matrix)
    n = len(matrix[0])
    left = 0
    right = m * n - 1
    while left <= right:
        mid = left + (right - left) // 2
        mid_val = matrix[mid // n][mid % n]
        if mid_val == target:
            return true
        elif mid_val < target:
            left = mid + 1
        else:
            right = mid - 1
    return false
```
* **Key Details Interviewers Look For:**
  * Treating matrix as a sorted list
  * Correct index calculations
  * Binary search implementation
### 5.9 Find Peak Element<!-- {"fold":true} -->
* **Problem Statement:**
  * A peak element is an element that is greater than its neighbors. Find a peak element in the array.
* **Key Identifiers:**
  * Array of integers
  * Peak element definition
  * Return index of a peak
* **Pseudocode:**
```
function findPeakElement(nums):
    left = 0
    right = len(nums) - 1
    while left < right:
        mid = left + (right - left) // 2
        if nums[mid] > nums[mid + 1]:
            right = mid
        else:
            left = mid + 1
    return left
```
* **Key Details Interviewers Look For:**
  * Binary search for peak
  * Understanding of local maxima
  * Time complexity of O(log n)
### 5.10 Search in a Binary Search Tree
* **Problem Statement:**
  * Search for a value in a Binary Search Tree (BST) and return the subtree rooted with that node.
* **Key Identifiers:**
  * Binary Search Tree
  * Search value
  * Return subtree or null
* **Pseudocode:**
```
function searchBST(root, val):
    if root is null or root.val == val:
        return root
    if val < root.val:
        return searchBST(root.left, val)
    else:
        return searchBST(root.right, val)
```
* **Key Details Interviewers Look For:**
  * Leveraging BST properties for efficient search
  * Recursive vs. iterative implementation
  * Correct traversal based on comparison
----
## 6. Dynamic Programming
### 6.1 Climbing Stairs<!-- {"fold":true} -->
* **Problem Statement:**
  * You are climbing a staircase. It takes n steps to reach the top. Each time you can climb 1 or 2 steps. In how many distinct ways can you climb to the top?
* **Key Identifiers:**
  * Number of steps n
  * Climbing 1 or 2 steps
  * Return number of ways
* **Pseudocode:**
```
function climbStairs(n):
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2
    for i from 3 to n:
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```
* **Key Details Interviewers Look For:**
  * Identifying the recurrence relation
  * Dynamic programming vs. recursion
  * Space optimization (using variables instead of array)
### 6.2 House Robber<!-- {"fold":true} -->
* **Problem Statement:**
  * You are a professional robber planning to rob houses along a street. Each house has a certain amount of money. Adjacent houses cannot be robbed on the same night. Determine the maximum amount of money you can rob tonight without alerting the police.
* **Key Identifiers:**
  * Array of integers (money in houses)
  * No two adjacent houses
  * Return maximum money
* **Pseudocode:**
```
function rob(nums):
    prev1 = 0
    prev2 = 0
    for num in nums:
        temp = prev1
        prev1 = max(prev2 + num, prev1)
        prev2 = temp
    return prev1
```
* **Key Details Interviewers Look For:**
  * Dynamic programming approach
  * Optimal substructure identification
  * Space-efficient solution

### 6.3 Longest Increasing Subsequence<!-- {"fold":true} -->

* **Problem Statement:**
  * Find the length of the longest increasing subsequence in an unsorted array of integers.
* **Key Identifiers:**
  * Unsorted array
  * Longest increasing subsequence
  * Return length
* **Pseudocode:**
```
function lengthOfLIS(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i from 1 to len(nums) - 1:
        for j from 0 to i - 1:
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```
* **Key Details Interviewers Look For:**
  * Nested loops for DP solution
  * Time complexity optimization (e.g., using binary search)
  * Correctly updating DP array
### 6.4 Coin Change<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an integer array coins representing coins of different denominations and an integer amount, compute the fewest number of coins that you need to make up that amount.
* **Key Identifiers:**
  * Array of coin denominations
  * Target amount
  * Return minimum number of coins
* **Pseudocode:**
```
function coinChange(coins, amount):
    dp = [amount + 1] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for x from coin to amount:
            dp[x] = min(dp[x], dp[x - coin] + 1)
    return dp[amount] if dp[amount] != amount + 1 else -1
```
* **Key Details Interviewers Look For:**
  * Bottom-up dynamic programming approach
  * Correct initialization of DP array
  * Handling cases where amount cannot be formed
### 6.5 Unique Paths<!-- {"fold":true} -->
* **Problem Statement:**
  * A robot is located at the top-left corner of an m x n grid. It can only move either down or right at any point. Find the number of unique paths to reach the bottom-right corner.
* **Key Identifiers:**
  * m x n grid
  * Move right or down
  * Return number of unique paths
* **Pseudocode:**
```
function uniquePaths(m, n):
    dp = [1] * n
    for i from 1 to m - 1:
        for j from 1 to n - 1:
            dp[j] += dp[j - 1]
    return dp[-1]
```
* **Key Details Interviewers Look For:**
  * Dynamic programming table setup
  * Optimizing space usage
  * Understanding combinatorial paths
### 6.6 Decode Ways<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a string containing only digits, determine the total number of ways to decode it.
* **Key Identifiers:**
  * String of digits
  * Mapping to letters (A-Z)
  * Return number of decoding ways
* **Pseudocode:**
```
function numDecodings(s):
    if not s or s[0] == '0':
        return 0
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    for i from 2 to n:
        one = int(s[i-1:i])
        two = int(s[i-2:i])
        if 1 <= one <= 9:
            dp[i] += dp[i-1]
        if 10 <= two <= 26:
            dp[i] += dp[i-2]
    return dp[n]
```
* **Key Details Interviewers Look For:**
  * Handling single and double digit mappings
  * Managing leading zeros
  * Dynamic programming approach
### 6.7 Edit Distance<!-- {"fold":true} -->
* **Problem Statement:**
  * Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.
* **Key Identifiers:**
  * Two strings
  * Operations: insert, delete, replace
  * Return minimum operations
* **Pseudocode:**
```
function minDistance(word1, word2):
    m = len(word1)
    n = len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i from 0 to m:
        dp[i][0] = i
    for j from 0 to n:
        dp[0][j] = j
    for i from 1 to m:
        for j from 1 to n:
            if word1[i-1] == word2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    return dp[m][n]
```
* **Key Details Interviewers Look For:**
  * Correct initialization of DP table
  * Handling of different operations
  * Space and time complexity optimization
### 6.8 Partition Equal Subset Sum<!-- {"fold":true} -->
* **Problem Statement:**
  * Determine if a given set can be partitioned into two subsets such that the sum of elements in both subsets is equal.
* **Key Identifiers:**
  * Array of integers
  * Partition into two equal subsets
  * Return boolean
  * **Pseudocode:**
```
function canPartition(nums):
    total = sum(nums)
    if total % 2 != 0:
        return false
    target = total // 2
    dp = [False] * (target + 1)
    dp[0] = True
    for num in nums:
        for j from target down to num:
            dp[j] = dp[j] or dp[j - num]
    return dp[target]
```
* **Key Details Interviewers Look For:**
  * Transforming problem to subset sum
  * Dynamic programming approach
  * Space optimization techniques
### 6.9 Longest Palindromic Substring<!-- {"fold":true} -->
* **Problem Statement:**
  * Find the longest palindromic substring in a given string.
* **Key Identifiers:**
  * String input
  * Longest palindromic substring
  * Return substring
* **Pseudocode:**
```
function longestPalindrome(s):
    if not s:
        return ""
    start = end = 0
    for i from 0 to len(s) - 1:
        len1 = expandAroundCenter(s, i, i)
        len2 = expandAroundCenter(s, i, i + 1)
        max_len = max(len1, len2)
        if max_len > end - start:
            start = i - (max_len - 1) // 2
            end = i + max_len // 2
    return s[start:end+1]

function expandAroundCenter(s, left, right):
    while left >= 0 and right < len(s) and s[left] == s[right]:
        left -= 1
        right += 1
    return right - left - 1
```
* **Key Details Interviewers Look For:**
  * Center expansion technique
  * Handling odd and even length palindromes
  * Time and space complexity
### 6.10 Longest Common Subsequence<!-- {"fold":true} -->
* **Problem Statement:**
  * Given two strings text1 and text2, return the length of their longest common subsequence.
* **Key Identifiers:**
  * Two strings
  * Longest common subsequence
  * Return length
* **Pseudocode:**
```
function longestCommonSubsequence(text1, text2):
    m = len(text1)
    n = len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i from 1 to m:
        for j from 1 to n:
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]
```
* **Key Details Interviewers Look For:**
  * Dynamic programming table setup
  * Correct identification of subsequence vs. substring
  * Optimization of space usage
### 6.11 Maximum Product Subarray<!-- {"fold":true} -->
* **Problem Statement:**
  * Find the contiguous subarray within an array which has the largest product.
* **Key Identifiers:**
  * Array of integers
  * Contiguous subarray
  * Maximum product
* **Pseudocode:**
```
function maxProduct(nums):
    if not nums:
        return 0
    max_prod = min_prod = result = nums[0]
    for i from 1 to len(nums) - 1:
        if nums[i] < 0:
            max_prod, min_prod = min_prod, max_prod
        max_prod = max(nums[i], max_prod * nums[i])
        min_prod = min(nums[i], min_prod * nums[i])
        result = max(result, max_prod)
    return result
```
* **Key Details Interviewers Look For:**
  * Tracking both maximum and minimum products
  * Handling negative numbers
  * Efficient single pass solution
### 6.12 Burst Balloons<!-- {"fold":true} -->
* **Problem Statement:**
  * Given n balloons, each with a number, find the maximum coins you can collect by bursting the balloons wisely.
* **Key Identifiers:**
  * Array of integers (balloon values)
  * Burst balloons for coins
  * Return maximum coins
* **Pseudocode:**
```
function maxCoins(nums):
    n = len(nums)
    nums = [1] + nums + [1]
    dp = [[0] * (n + 2) for _ in range(n + 2)]
    for length from 1 to n:
        for left from 1 to n - length + 1:
            right = left + length - 1
            for i from left to right:
                dp[left][right] = max(dp[left][right],
                                      dp[left][i-1] + nums[left-1] * nums[i] * nums[right+1] + dp[i+1][right])
    return dp[1][n]
```
* **Key Details Interviewers Look For:**
  * Understanding of dynamic programming intervals
  * Optimal substructure identification
  * Correct handling of boundary conditions
### 6.13 Dungeon Game<!-- {"fold":true} -->
* **Problem Statement:**
  * The demons had captured the princess and imprisoned her in the bottom-right corner of a dungeon. Find the minimum initial health required to rescue the princess.
* **Key Identifiers:**
  * 2D grid (dungeon)
  * Minimum initial health
  * Return integer value
* **Pseudocode:**
```
function calculateMinimumHP(dungeon):
    m = len(dungeon)
    n = len(dungeon[0])
    dp = [[0] * n for _ in range(m)]
    dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])
    for i from m-2 to 0:
        dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])
    for j from n-2 to 0:
        dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])
    for i from m-2 to 0:
        for j from n-2 to 0:
            min_health = min(dp[i+1][j], dp[i][j+1])
            dp[i][j] = max(1, min_health - dungeon[i][j])
    return dp[0][0]
```
* **Key Details Interviewers Look For:**
  * Reverse traversal of the grid
  * Dynamic programming for optimal path
  * Handling of health boundaries
### 6.14 Decode Ways II<!-- {"fold":true} -->
* **Problem Statement:**
  * Similar to Decode Ways, but the string may contain â€˜*â€™ characters which can represent any digit from 1 to 9.
* **Key Identifiers:**
  * String with digits and â€˜*â€™
  * Decode ways considering â€˜*â€™
  * Return number of decoding ways modulo 10^9 + 7
* **Pseudocode:**
```
function numDecodingsII(s):
    MOD = 10**9 + 7
    n = len(s)
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 9 if s[0] == '*' else (1 if s[0] != '0' else 0)
    for i from 2 to n:
        single = s[i-1]
        double = s[i-2:i]
        if single == '*':
            dp[i] += 9 * dp[i-1]
        elif single != '0':
            dp[i] += dp[i-1]
        if double == '**':
            dp[i] += 15 * dp[i-2]
        elif double[0] == '*' and double[1] <= '6':
            dp[i] += 2 * dp[i-2]
        elif double[0] == '*' and double[1] > '6':
            dp[i] += dp[i-2]
        elif double[1] == '*' and double[0] == '1':
            dp[i] += 9 * dp[i-2]
        elif double[1] == '*' and double[0] == '2':
            dp[i] += 6 * dp[i-2]
        elif '10' <= double <= '26':
            dp[i] += dp[i-2]
        dp[i] %= MOD
    return dp[n]
```
* **Key Details Interviewers Look For:**
  * Handling wildcard â€˜*â€™ in decoding
  * Managing multiple cases for â€˜*â€™
  * Dynamic programming with modulo operations
### 6.15 Longest Palindromic Subsequence<!-- {"fold":true} -->
* **Problem Statement:**
  * Find the length of the longest palindromic subsequence in a given string.
* **Key Identifiers:**
  * String input
  * Longest palindromic subsequence
  * Return length
* **Pseudocode:**
```
function longestPalindromeSubseq(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    for i from n-1 to 0:
        dp[i][i] = 1
        for j from i+1 to n-1:
            if s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    return dp[0][n-1]
```
* **Key Details Interviewers Look For:**
  * Dynamic programming approach
  * Correctly identifying palindromic conditions
  * Time and space optimization
### 6.16 Palindrome Partitioning<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.
* **Key Identifiers:**
  * String input
  * Palindromic substrings
  * Return list of partitions
* **Pseudocode:**
```
function partition(s):
    result = []
    current = []
    backtrack(s, 0, current, result)
    return result

function backtrack(s, start, current, result):
    if start == len(s):
        result.append(list(current))
        return
    for end from start to len(s):
        if isPalindrome(s, start, end):
            current.append(s[start:end+1])
            backtrack(s, end+1, current, result)
            current.pop()

function isPalindrome(s, left, right):
    while left < right:
        if s[left] != s[right]:
            return false
        left += 1
        right -= 1
    return true
```
* **Key Details Interviewers Look For:**
  * Backtracking approach
  * Pruning non-palindromic paths
  * Correctly building and backtracking partitions
### 6.17 Unique Paths II<!-- {"fold":true} -->
* **Problem Statement:**
  * Similar to Unique Paths, but some cells are obstacles. Find the number of unique paths avoiding obstacles.
* **Key Identifiers:**
  * m x n grid with obstacles
  * Move right or down
  * Return number of unique paths
* **Pseudocode:**
```
function uniquePathsWithObstacles(obstacleGrid):
    m = len(obstacleGrid)
    n = len(obstacleGrid[0])
    dp = [0] * n
    dp[0] = 1 if obstacleGrid[0][0] == 0 else 0
    for i from 0 to m - 1:
        for j from 0 to n - 1:
            if obstacleGrid[i][j] == 1:
                dp[j] = 0
            elif j > 0:
                dp[j] += dp[j - 1]
    return dp[-1]
```
* **Key Details Interviewers Look For:**
  * Adjusting DP for obstacles
  * Correct initialization based on obstacles
  * Space optimization techniques
### 6.18 Word Break<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a string s and a dictionary of strings wordDict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.
* **Key Identifiers:**
  * String s
  * Word dictionary wordDict
  * Return boolean
* **Pseudocode:**
```
function wordBreak(s, wordDict):
    word_set = set(wordDict)
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i from 1 to len(s):
        for j from 0 to i:
            if dp[j] and s[j:i] in word_set:
                dp[i] = True
                break
    return dp[len(s)]
```
* **Key Details Interviewers Look For:**
  * Dynamic programming approach
  * Efficient substring checking
  * Handling overlapping words
### 6.19 Longest Arithmetic Subsequence<!-- {"fold":true} -->

* **Problem Statement:**
  * Given an array A of integers, return the length of the longest arithmetic subsequence in A.
* **Key Identifiers:**
  * Array of integers
  * Arithmetic subsequence
  * Return length
* **Pseudocode:**
```
function longestArithSeqLength(A):
    dp = [{} for _ in range(len(A))]
    max_len = 0
    for i from 1 to len(A) - 1:
        for j from 0 to i - 1:
            diff = A[i] - A[j]
            dp[i][diff] = dp[j].get(diff, 1) + 1
            max_len = max(max_len, dp[i][diff])
    return max_len
```
* **Key Details Interviewers Look For:**
  * Using hash maps to track differences
  * Dynamic programming for subsequence lengths
  * Efficient handling of differences
### 6.20 Longest Valid Parentheses<!-- {"fold":true} -->
* **Problem Statement:**
  * Find the length of the longest valid (well-formed) parentheses substring.
* **Key Identifiers:**
  * String of parentheses
  * Longest valid substring
  * Return length
* **Pseudocode:**
```
function longestValidParentheses(s):
    stack = [-1]
    max_length = 0
    for i from 0 to len(s) - 1:
        if s[i] == '(':
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                max_length = max(max_length, i - stack[-1])
    return max_length
```
* **Key Details Interviewers Look For:**
  * Use of stack to track indices
  * Handling unmatched parentheses
  * Correct calculation of valid lengths
-----
## 7. Recursion and Backtracking
### 7.1 Permutations<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an array nums of distinct integers, return all possible permutations.
* **Key Identifiers:**
  * Array of distinct integers
  * All possible permutations
  * Return list of permutations
* **Pseudocode:**
```
function permute(nums):
    result = []
    backtrack(nums, [], result)
    return result

function backtrack(nums, path, result):
    if not nums:
        result.append(list(path))
        return
    for i from 0 to len(nums) - 1:
        path.append(nums[i])
        backtrack(nums[:i] + nums[i+1:], path, result)
        path.pop()
```
* **Key Details Interviewers Look For:**
  * Backtracking approach
  * Correctly managing visited elements
  * Efficiency in recursion
### 7.2 Subsets<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an integer array nums, return all possible subsets (the power set).
* **Key Identifiers:**
  * Array of integers
  * All subsets
  * Return list of subsets
* **Pseudocode:**
```
function subsets(nums):
    result = []
    backtrack(nums, 0, [], result)
    return result

function backtrack(nums, start, path, result):
    result.append(list(path))
    for i from start to len(nums) - 1:
        path.append(nums[i])
        backtrack(nums, i + 1, path, result)
        path.pop()
```
* **Key Details Interviewers Look For:**
  * Recursive backtracking to generate subsets
  * Managing start index to avoid duplicates
  * Handling empty and full subsets
### 7.3 Combination Sum<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an array of distinct integers candidates and a target integer target, return all unique combinations where the candidate numbers sum to target.
* **Key Identifiers:**
  * Array of distinct integers
  * Target sum
  * Return unique combinations
* **Pseudocode:**
```
function combinationSum(candidates, target):
    candidates.sort()
    result = []
    backtrack(candidates, target, 0, [], result)
    return result

function backtrack(candidates, target, start, path, result):
    if target == 0:
        result.append(list(path))
        return
    for i from start to len(candidates) - 1:
        if candidates[i] > target:
            break
        path.append(candidates[i])
        backtrack(candidates, target - candidates[i], i, path, result)
        path.pop()
```
* **Key Details Interviewers Look For:**
  * Allowing repeated elements
  * Backtracking with pruning
  * Correctly handling duplicates
### 7.4 N-Queens
* **Problem Statement:**
  * The n-queens puzzle is the problem of placing n queens on an nÃ—n chessboard so that no two queens threaten each other. Return all distinct solutions.
* **Key Identifiers:**
  * n x n chessboard
  * Place n queens without conflict
  * Return list of solutions
* **Pseudocode:**
```
function solveNQueens(n):
    result = []
    backtrack([], 0, n, result)
    return result

function backtrack(board, row, n, result):
    if row == n:
        result.append(formatBoard(board, n))
        return
    for col from 0 to n - 1:
        if isSafe(board, row, col):
            board.append(col)
            backtrack(board, row + 1, n, result)
            board.pop()

function isSafe(board, row, col):
    for r from 0 to row - 1:
        c = board[r]
        if c == col or abs(c - col) == row - r:
            return false
    return true

function formatBoard(board, n):
    formatted = []
    for col in board:
        row = ['.'] * n
        row[col] = 'Q'
        formatted.append(''.join(row))
    return formatted
```
* **Key Details Interviewers Look For:**
  * Backtracking with constraint checks
  * Efficient conflict detection
  * Correctly formatting solutions
### 7.5 Letter Combinations of a Phone Number<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
* **Key Identifiers:**
  * String of digits (2-9)
  * Letter mapping (phone keypad)
  * Return list of combinations
* **Pseudocode:**
```
function letterCombinations(digits):
    if not digits:
        return []
    mapping = {
        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
    }
    result = []
    backtrack(digits, 0, [], result, mapping)
    return result

function backtrack(digits, index, path, result, mapping):
    if index == len(digits):
        result.append(''.join(path))
        return
    for char in mapping[digits[index]]:
        path.append(char)
        backtrack(digits, index + 1, path, result, mapping)
        path.pop()
```
* **Key Details Interviewers Look For:**
  * Mapping digits to letters
  * Backtracking to generate combinations
  * Handling empty input
### 7.6 Word Search<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a 2D board and a word, find if the word exists in the grid by moving horizontally or vertically.
* **Key Identifiers:**
  * 2D grid of characters
  * Search word
  * Return boolean
* **Pseudocode:**
```
function exist(board, word):
    m = len(board)
    n = len(board[0])
    for i from 0 to m - 1:
        for j from 0 to n - 1:
            if backtrack(board, word, i, j, 0):
                return true
    return false

function backtrack(board, word, i, j, index):
    if index == len(word):
        return true
    if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[index]:
        return false
    temp = board[i][j]
    board[i][j] = '#'
    found = backtrack(board, word, i+1, j, index+1) or
            backtrack(board, word, i-1, j, index+1) or
            backtrack(board, word, i, j+1, index+1) or
            backtrack(board, word, i, j-1, index+1)
    board[i][j] = temp
    return found
```
* **Key Details Interviewers Look For:**
  * Backtracking with DFS
  * Marking visited cells
  * Handling boundary conditions
### 7.7 Combination Sum II<!-- {"fold":true} -->
* **Problem Statement:**
  * Similar to Combination Sum, but each number in candidates may only be used once.
* **Key Identifiers:**
  * Array of integers (with duplicates)
  * Target sum
  * Return unique combinations
* **Pseudocode:**
```
function combinationSum2(candidates, target):
    candidates.sort()
    result = []
    backtrack(candidates, target, 0, [], result)
    return result

function backtrack(candidates, target, start, path, result):
    if target == 0:
        result.append(list(path))
        return
    for i from start to len(candidates) - 1:
        if i > start and candidates[i] == candidates[i-1]:
            continue
        if candidates[i] > target:
            break
        path.append(candidates[i])
        backtrack(candidates, target - candidates[i], i + 1, path, result)
        path.pop()
```
* **Key Details Interviewers Look For:**
  * Handling duplicates by sorting and skipping
  * Ensuring each element is used once
  * Efficient backtracking with pruning
### 7.8 Generate Parentheses<!-- {"fold":true} -->
* **Problem Statement:**
  * Generate all combinations of well-formed parentheses for a given number n.
* **Key Identifiers:**
  * Number n pairs
  * Well-formed parentheses
  * Return list of combinations
* **Pseudocode:**
```
function generateParenthesis(n):
    result = []
    backtrack(result, "", 0, 0, n)
    return result

function backtrack(result, current, open, close, max):
    if len(current) == 2 * max:
        result.append(current)
        return
    if open < max:
        backtrack(result, current + "(", open + 1, close, max)
    if close < open:
        backtrack(result, current + ")", open, close + 1, max)
```
* **Key Details Interviewers Look For:**
  * Maintaining balance of parentheses
  * Backtracking with constraints on open and close
  * Efficient generation without duplicates
### 7.9 Restore IP Addresses<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a string containing only digits, restore it by returning all possible valid IP address combinations.
* **Key Identifiers:**
  * String of digits
  * Valid IP address segments
  * Return list of valid IPs
* **Pseudocode:**
```
function restoreIpAddresses(s):
    result = []
    backtrack(s, 0, [], result)
    return result

function backtrack(s, start, path, result):
    if len(path) == 4:
        if start == len(s):
            result.append('.'.join(path))
        return
    for length from 1 to 3:
        if start + length > len(s):
            break
        segment = s[start:start + length]
        if isValid(segment):
            path.append(segment)
            backtrack(s, start + length, path, result)
            path.pop()

function isValid(segment):
    if len(segment) == 0 or (len(segment) > 1 and segment[0] == '0'):
        return false
    if not 0 <= int(segment) <= 255:
        return false
    return true
```
* **Key Details Interviewers Look For:**
  * Backtracking with fixed number of segments
  * Validating each IP segment
  * Handling leading zeros
### 7.10 Combination Sum III<!-- {"fold":true} -->
* **Problem Statement:**
  * Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be unique.
* **Key Identifiers:**
  * Numbers 1-9
  * Combination size k
  * Target sum n
  * Return list of combinations
* **Pseudocode:**
```
function combinationSum3(k, n):
    result = []
    backtrack(1, k, n, [], result)
    return result

function backtrack(start, k, n, path, result):
    if k == 0 and n == 0:
        result.append(list(path))
        return
    if k == 0 or n < 0:
        return
    for i from start to 9:
        path.append(i)
        backtrack(i + 1, k - 1, n - i, path, result)
        path.pop()
```
* **Key Details Interviewers Look For:**
  * Unique combinations by incrementing start
  * Backtracking with constraints on size and sum
  * Pruning paths that exceed target
### 7.11 Sudoku Solver<!-- {"fold":true} -->
* **Problem Statement:**
  * Write a program to solve a Sudoku puzzle by filling the empty cells.
* **Key Identifiers:**
  * 9x9 Sudoku grid
  * Fill empty cells with valid numbers
  * Modify grid in-place
* **Pseudocode:**
```
function solveSudoku(board):
    solve(board)

function solve(board):
    for i from 0 to 8:
        for j from 0 to 8:
            if board[i][j] == '.':
                for c from '1' to '9':
                    if isValid(board, i, j, c):
                        board[i][j] = c
                        if solve(board):
                            return true
                        board[i][j] = '.'
                return false
    return true

function isValid(board, row, col, c):
    for i from 0 to 8:
        if board[i][col] == c or board[row][i] == c:
            return false
    startRow = (row // 3) * 3
    startCol = (col // 3) * 3
    for i from startRow to startRow + 3:
        for j from startCol to startCol + 3:
            if board[i][j] == c:
                return false
    return true
```
* **Key Details Interviewers Look For:**
  * Backtracking approach
  * Validity checks for Sudoku rules
  * Optimizing search to reduce time
### 7.12 Letter Case Permutation<!-- {"fold":true} -->

* **Problem Statement:**
  * Given a string s, you can transform every letter individually to be lowercase or uppercase. Return a list of all possible permutations.
* **Key Identifiers:**
  * String with letters and digits
  * Transform letters to lowercase or uppercase
  * Return list of permutations
* **Pseudocode:**
```
function letterCasePermutation(s):
    result = []
    backtrack(s, 0, "", result)
    return result

function backtrack(s, index, path, result):
    if index == len(s):
        result.append(path)
        return
    if s[index].isalpha():
        backtrack(s, index + 1, path + s[index].lower(), result)
        backtrack(s, index + 1, path + s[index].upper(), result)
    else:
        backtrack(s, index + 1, path + s[index], result)
```
* **Key Details Interviewers Look For:**
  * Handling letters and digits separately
  * Backtracking to explore all cases
  * Efficient string manipulation

### 7.13 Generate All Binary Strings<!-- {"fold":true} -->
* **Problem Statement:**
  * Generate all binary strings of length n.
* **Key Identifiers:**
  * Integer n
  * Binary strings of length n
  * Return list of strings
* **Pseudocode:**
```
function generateBinaryStrings(n):
    result = []
    backtrack(n, "", result)
    return result

function backtrack(n, path, result):
    if len(path) == n:
        result.append(path)
        return
    backtrack(n, path + "0", result)
    backtrack(n, path + "1", result)
```
* **Key Details Interviewers Look For:**
  * Recursive generation of strings
  * Managing binary choices at each step
  * Handling base cases correctly
### 7.14 Generate All Combinations of Well-Formed Parentheses<!-- {"fold":true} -->
* **Problem Statement:**
  * Similar to Generate Parentheses, but ensuring all combinations are well-formed.
* **Key Identifiers:**
  * Number of pairs n
  * Well-formed parentheses
  * Return list of combinations
* **Pseudocode:**
```
function generateParenthesis(n):
    result = []
    backtrack(result, "", 0, 0, n)
    return result

function backtrack(result, current, open, close, max):
    if len(current) == 2 * max:
        result.append(current)
        return
    if open < max:
        backtrack(result, current + "(", open + 1, close, max)
    if close < open:
        backtrack(result, current + ")", open, close + 1, max)
```
* **Key Details Interviewers Look For:**
  * Ensuring balance between open and close
  * Efficiently generating only valid strings
  * Pruning invalid paths early

### 7.15 Combination Sum IV<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an integer array nums and a target integer target, return the number of possible combinations that add up to target.
* **Key Identifiers:**
  * Array of integers
  * Target sum
  * Return number of combinations
* **Pseudocode:**
```
function combinationSum4(nums, target):
    dp = [0] * (target + 1)
    dp[0] = 1
    for i from 1 to target:
        for num in nums:
            if i >= num:
                dp[i] += dp[i - num]
    return dp[target]
```
* **Key Details Interviewers Look For:**
  * Dynamic programming approach
  * Order matters in combinations
  * Handling of repeated elements
### 7.16 Generate All Possible Full Binary Trees<!-- {"fold":true} -->
* **Problem Statement:**
  * Generate all possible full binary trees with n nodes.
* **Key Identifiers:**
  * Integer n (odd)
  * Full binary trees (each node has 0 or 2 children)
  * Return list of trees
* **Pseudocode:**
```
function allPossibleFBT(n):
    if n % 2 == 0:
        return []
    if n == 1:
        return [TreeNode(0)]
    result = []
    for left_nodes in range(1, n, 2):
        right_nodes = n - 1 - left_nodes
        left_trees = allPossibleFBT(left_nodes)
        right_trees = allPossibleFBT(right_nodes)
        for left in left_trees:
            for right in right_trees:
                root = TreeNode(0)
                root.left = left
                root.right = right
                result.append(root)
    return result
```
* **Key Details Interviewers Look For:**
  * Recursive tree generation
  * Ensuring all trees are full
  * Memoization for optimization (if applicable)
### 7.17 Letter Combinations of a Phone Number with Repeating Characters<!-- {"fold":true} -->
* **Problem Statement:**
  * Similar to Letter Combinations, but allow letters to repeat based on input characters.
* **Key Identifiers:**
  * String with digits
  * Repeating letters based on input
  * Return list of combinations
* **Pseudocode:**
```
function letterCombinationsWithRepeats(digits):
    if not digits:
        return []
    mapping = {
        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
    }
    result = []
    backtrack(digits, 0, "", result, mapping)
    return result

function backtrack(digits, index, path, result, mapping):
    if index == len(digits):
        result.append(path)
        return
    for char in mapping[digits[index]]:
        backtrack(digits, index + 1, path + char, result, mapping)
```
* **Key Details Interviewers Look For:**
  * Correct mapping of digits to letters
  * Allowing repeated letters as per digits
  * Efficient backtracking implementation
### 7.18 Combination Sum III<!-- {"fold":true} -->
* **Problem Statement:**
  * Find all possible combinations of k numbers that add up to a number n, with numbers ranging from 1 to 9 and each number used at most once.
* **Key Identifiers:**
  * Numbers 1-9
  * Combination size k
  * Target sum n
  * Return list of combinations
* **Pseudocode:**
```
function combinationSum3(k, n):
    result = []
    backtrack(1, k, n, [], result)
    return result

function backtrack(start, k, n, path, result):
    if k == 0 and n == 0:
        result.append(list(path))
        return
    if k == 0 or n < 0:
        return
    for i from start to 9:
        path.append(i)
        backtrack(i + 1, k - 1, n - i, path, result)
        path.pop()
```
* **Key Details Interviewers Look For:**
  * Ensuring unique numbers in combinations
  * Backtracking with correct constraints
  * Efficient pruning of invalid paths

### 7.19 Restore IP Addresses with Obfuscated Input<!-- {"fold":true} -->
* **Problem Statement:**
  * Similar to Restore IP Addresses, but some digits are obfuscated and represented by â€˜*â€™. Restore all valid IP addresses considering possible digit replacements.
* **Key Identifiers:**
  * String with digits and â€˜*â€™
  * Valid IP address segments
  * Return list of valid IPs
* **Pseudocode:**
```
function restoreIPAddressesWithStars(s):
    result = []
    backtrack(s, 0, [], result)
    return result

function backtrack(s, start, path, result):
    if len(path) == 4:
        if start == len(s):
            result.append('.'.join(path))
        return
    for length from 1 to 3:
        if start + length > len(s):
            break
        segment = s[start:start + length]
        for possible in generatePossibleSegments(segment):
            if isValid(possible):
                path.append(possible)
                backtrack(s, start + length, path, result)
                path.pop()

function generatePossibleSegments(segment):
    # Replace '*' with digits 0-9 and return all possible strings
    if '*' not in segment:
        return [segment]
    results = []
    for i in range(len(segment)):
        if segment[i] == '*':
            for digit in '0123456789':
                new_segment = segment[:i] + digit + segment[i+1:]
                results.extend(generatePossibleSegments(new_segment))
            return results
    return [segment]
```
* **Key Details Interviewers Look For:**
  * Handling wildcard â€˜*â€™ in segments
  * Generating all possible replacements
  * Ensuring segments are valid IP parts
### 7.20 Combination Sum IV with Constraints
* **Problem Statement:**
  * Similar to Combination Sum IV, but with additional constraints on the order of elements.
* **Key Identifiers:**
  * Array of integers
  * Target sum with order constraints
  * Return number of combinations
* **Pseudocode:**
```
function combinationSum4WithConstraints(nums, target, constraint):
    dp = [0] * (target + 1)
    dp[0] = 1
    for i from 1 to target:
        for num in nums:
            if i >= num and satisfiesConstraint(i, num, constraint):
                dp[i] += dp[i - num]
    return dp[target]
```
*Note: The* *satisfiesConstraint* *function needs to be defined based on the specific constraints.*
* **Key Details Interviewers Look For:**
  * Incorporating additional constraints into DP
  * Ensuring combinations meet specified conditions
  * Adjusting DP transitions accordingly
------
## 8. Bit Manipulation<!-- {"fold":true} -->
### 8.1 Single Number<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a non-empty array of integers, every element appears twice except for one. Find that single one.
* **Key Identifiers:**
  * Array of integers
  * Every element appears twice except one
  * Return the single number
* **Pseudocode:**
```
function singleNumber(nums):
    result = 0
    for num in nums:
        result ^= num
    return result
```
* **Key Details Interviewers Look For:**
  * Use of XOR operation
  * Understanding bitwise properties
  * Space-efficient solution
### 8.2 Hamming Distance<!-- {"fold":true} -->
* **Problem Statement:**
  * The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Compute the Hamming distance.
* **Key Identifiers:**
  * Two integers
  * Bit difference count
  * Return integer distance
* **Pseudocode:**
```
function hammingDistance(x, y):
    xor = x ^ y
    distance = 0
    while xor:
        distance += xor & 1
        xor >>= 1
    return distance
```
* **Key Details Interviewers Look For:**
  * Bitwise XOR to find differing bits
  * Counting set bits
  * Alternative methods (Brian Kernighanâ€™s algorithm)
### 8.3 Number of 1 Bits<!-- {"fold":true} -->
* **Problem Statement:**
  * Write a function that takes an unsigned integer and returns the number of â€˜1â€™ bits it has.
* **Key Identifiers:**
  * Unsigned integer
  * Count â€˜1â€™ bits
  * Return count
* **Pseudocode:**
```
function hammingWeight(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count
```
* **Key Details Interviewers Look For:**
  * Bitwise operations to count bits
  * Efficient looping
  * Handling of edge cases (e.g., n = 0)
### 8.4 Power of Two<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an integer, write a function to determine if it is a power of two.
* **Key Identifiers:**
  * Integer input
  * Check if power of two
  * Return boolean
* **Pseudocode:**
```
function isPowerOfTwo(n):
    return n > 0 and (n & (n - 1)) == 0

```
* **Key Details Interviewers Look For:**
  * Bitwise trick to check power of two
  * Understanding binary representations
  * Edge case handling (n <= 0)

### 8.5 Counting Bits<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a non-negative integer num, return an array containing the number of 1â€™s in the binary representation of each number from 0 to num.
* **Key Identifiers:**
  * Integer num
  * Count â€˜1â€™ bits for each number
  * Return array of counts
* **Pseudocode:**
```
function countBits(num):
    dp = [0] * (num + 1)
    for i from 1 to num:
        dp[i] = dp[i >> 1] + (i & 1)
    return dp
```
* **Key Details Interviewers Look For:**
  * Dynamic programming approach
  * Efficient bit manipulation
  * Understanding of binary patterns
### 8.6 Reverse Bits<!-- {"fold":true} -->
* **Problem Statement:**
  * Reverse the bits of a given 32 bits unsigned integer.
* **Key Identifiers:**
  * 32-bit unsigned integer
  * Reverse bits
  * Return reversed integer
* **Pseudocode:**
```
function reverseBits(n):
    result = 0
    for i from 0 to 31:
        result = (result << 1) | (n & 1)
        n >>= 1
    return result
```
* **Key Details Interviewers Look For:**
  * Bit shifting and masking
  * Correct handling of all 32 bits
  * Efficient single pass
### 8.7 Single Number II<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an array of integers, every element appears three times except for one. Find that single one.
* **Key Identifiers:**
  * Array of integers
  * Every element appears three times except one
  * Return the single number
* **Pseudocode:**
```
function singleNumberII(nums):
    ones = twos = 0
    for num in nums:
        ones = (ones ^ num) & ~twos
        twos = (twos ^ num) & ~ones
    return ones
```
* **Key Details Interviewers Look For:**
  * Bitwise operations to handle multiple occurrences
  * Understanding of finite state machines with bits
  * Space-efficient solution

### 8.8 Number Complement<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.
* **Key Identifiers:**
  * Positive integer
  * Flip bits
  * Return complement integer
  * **Pseudocode:**
```
function findComplement(num):
    mask = 1
    while mask < num:
        mask = (mask << 1) | 1
    return mask ^ num
```
* **Key Details Interviewers Look For:**
  * Creating a mask with all bits set
  * Bitwise XOR to flip bits
  * Handling of edge cases
### 8.9 Reverse Only Letters<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a string S, reverse only the letters and keep other characters in the same position.
* **Key Identifiers:**
  * String with letters and non-letters
  * Reverse only letters
  * Return modified string
* **Pseudocode:**
```
function reverseOnlyLetters(S):
    chars = list(S)
    left, right = 0, len(chars) - 1
    while left < right:
        if not chars[left].isalpha():
            left += 1
            continue
        if not chars[right].isalpha():
            right -= 1
            continue
        chars[left], chars[right] = chars[right], chars[left]
        left += 1
        right -= 1
    return ''.join(chars)
```
* **Key Details Interviewers Look For:**
  * Two-pointer approach
  * Identifying and skipping non-letter characters
  * In-place character swapping
### 8.10 Find All Numbers Disappeared in an Array<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an array of integers where 1 â‰¤ a[i] â‰¤ n (n = size of array), find all the elements of [1, n] inclusive that do not appear in this array.
* **Key Identifiers:**
  * Array of integers (1 â‰¤ a[i] â‰¤ n)
  * Find missing numbers
  * Return list of missing integers
* **Pseudocode:**
```
function findDisappearedNumbers(nums):
    for i from 0 to len(nums) - 1:
        index = abs(nums[i]) - 1
        if nums[index] > 0:
            nums[index] = -nums[index]
    result = []
    for i from 0 to len(nums) - 1:
        if nums[i] > 0:
            result.append(i + 1)
    return result
```
* **Key Details Interviewers Look For:**
  * In-place marking using indices
  * Handling duplicates
  * Space-efficient solution
----
## 9. Mathematical Problems<!-- {"fold":true} -->
### 9.1 Reverse Integer<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a 32-bit signed integer, reverse its digits. If reversing causes the integer to go outside the signed 32-bit integer range, return 0.
* **Key Identifiers:**
  * 32-bit signed integer
  * Reverse digits
  * Handle overflow
* **Pseudocode:**
```
function reverse(x):
    rev = 0
    sign = -1 if x < 0 else 1
    x = abs(x)
    while x != 0:
        pop = x % 10
        x = x // 10
        if rev > (2**31 - 1) // 10:
            return 0
        rev = rev * 10 + pop
    return sign * rev
```
* **Key Details Interviewers Look For:**
  * Handling negative numbers
  * Preventing overflow
  * Correct digit manipulation
### 9.2 Palindrome Number<!-- {"fold":true} -->

* **Problem Statement:**
  * Determine whether an integer is a palindrome without using extra space.
* **Key Identifiers:**
  * Integer input
  * Check palindrome
  * Return boolean
* **Pseudocode:**
```
function isPalindrome(x):
    if x < 0 or (x % 10 == 0 and x != 0):
        return false
    reversed = 0
    while x > reversed:
        reversed = reversed * 10 + x % 10
        x = x // 10
    return x == reversed or x == reversed // 10
```
* **Key Details Interviewers Look For:**
  * Avoiding extra space by reversing half the number
  * Handling edge cases (negative numbers, zeros)
  * Efficient digit manipulation
### 9.3 Excel Sheet Column Number<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a string representing the column title as appear in an Excel sheet, return its corresponding column number.
* **Key Identifiers:**
  * Excel column title (e.g., â€œAâ€, â€œABâ€)
  * Convert to number
  * Return integer
* **Pseudocode:**
```
function titleToNumber(s):
    result = 0
    for char in s:
        result = result * 26 + (ord(char) - ord('A') + 1)
    return result
```
* **Key Details Interviewers Look For:**
  * Understanding of base-26 number system
  * Correct mapping from characters to numbers
  * Handling multiple characters
### 9.4 Excel Sheet Column Title<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a positive integer, return its corresponding column title as appear in an Excel sheet.
* **Key Identifiers:**
  * Positive integer
  * Convert to Excel column title
  * Return string
* **Pseudocode:**
```
function numberToTitle(n):
    result = []
    while n > 0:
        n -= 1
        result.append(chr(n % 26 + ord('A')))
        n = n // 26
    return ''.join(reversed(result))
```
* **Key Details Interviewers Look For:**
  * Correct handling of 1-based indexing
  * Looping until number is zero
  * Building the string in reverse order
### 9.5 Roman to Integer<!-- {"fold":true} -->
* **Problem Statement:**
  * Convert a Roman numeral to an integer.
* **Key Identifiers:**
  * Roman numeral string
  * Convert to integer
  * Return integer value
* **Pseudocode:**
```
function romanToInt(s):
    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50,
            'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev = 0
    for char in reversed(s):
        current = roman[char]
        if current < prev:
            total -= current
        else:
            total += current
        prev = current
    return total
```
* **Key Details Interviewers Look For:**
  * Handling subtractive notation
  * Iterating from end to start
  * Efficient mapping and lookup
### 9.6 Integer to Roman<!-- {"fold":true} -->
* **Problem Statement:**
  * Convert an integer to a Roman numeral.
* **Key Identifiers:**
  * Integer input
  * Convert to Roman numeral
  * Return string
* **Pseudocode:**
```
function intToRoman(num):
    val = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    syms = [
        "M", "CM", "D", "CD",
        "C", "XC", "L", "XL",
        "X", "IX", "V", "IV",
        "I"
    ]
    roman = ""
    for i from 0 to len(val) - 1:
        while num >= val[i]:
            roman += syms[i]
            num -= val[i]
    return roman
```
* **Key Details Interviewers Look For:**
  * Correct handling of subtractive cases
  * Iterating through value-symbol pairs
  * Efficient string construction
### 9.7 Power of Four<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an integer, determine if it is a power of four.
* **Key Identifiers:**
  * Integer input
  * Check if power of four
  * Return boolean
* **Pseudocode:**
```

function isPowerOfFour(n):
    return n > 0 and (n & (n - 1)) == 0 and (n - 1) % 3 == 0
```
* **Key Details Interviewers Look For:**
  * Bitwise checks for power of two
  * Additional condition for power of four
  * Handling of edge cases

### 9.8 Fizz Buzz<!-- {"fold":true} -->
* **Problem Statement:**
  * Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three, output â€œFizzâ€ instead of the number and for the multiples of five, output â€œBuzzâ€. For numbers which are multiples of both three and five, output â€œFizzBuzzâ€.
* **Key Identifiers:**
  * Integer n
  * Multiples of 3 and 5
  * Return list of strings
* **Pseudocode:**
```
function fizzBuzz(n):
    result = []
    for i from 1 to n:
        if i % 15 == 0:
            result.append("FizzBuzz")
        elif i % 3 == 0:
            result.append("Fizz")
        elif i % 5 == 0:
            result.append("Buzz")
        else:
            result.append(str(i))
    return result
```
* **Key Details Interviewers Look For:**
  * Correctly handling multiple conditions
  * Efficient iteration
  * Clear and concise implementation

### 9.9 Missing Number<!-- {"fold":true} -->
* **Problem Statement:**
  * Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.
* **Key Identifiers:**
  * Array of size n with numbers 0 to n
  * Find missing number
  * Return integer
* **Pseudocode:**
```
function missingNumber(nums):
    n = len(nums)
    total = n * (n + 1) // 2
    return total - sum(nums)
```
* **Key Details Interviewers Look For:**
  * Mathematical approach using sum formula
  * Alternative methods (bitwise XOR)
  * Handling of edge cases

### 9.10 Number of Steps to Reduce a Number to Zero<!-- {"fold":true} -->
* **Problem Statement:**
  * Given a non-negative integer num, return the number of steps to reduce it to zero. In one step, if the current number is even, divide it by 2; otherwise, subtract 1 from it.
* **Key Identifiers:**
  * Non-negative integer
  * Reduce to zero with specific steps
  * Return step count
* **Pseudocode:**
```
function numberOfSteps(num):
    steps = 0
    while num != 0:
        if num % 2 == 0:
            num = num // 2
        else:
            num -= 1
        steps += 1
    return steps
```
* **Key Details Interviewers Look For:**
  * Iterative approach
  * Correct handling of even and odd cases
  * Efficient loop termination

------
## 10. System Design and Scalability<!-- {"fold":true} -->
### 10.1 Design a URL Shortener<!-- {"fold":true} -->
* **Problem Statement:**
  * Design a URL shortening service like TinyURL that encodes a long URL to a short one and decodes the short URL back to the original URL.
* **Key Identifiers:**
  * Encode long URLs to short URLs
  * Decode short URLs to original
  * Handle scalability and uniqueness
* **Pseudocode:**
```
class URLShortener:
    def __init__():
        self.counter = 1
        self.url_map = {}
        self.alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        self.base = 62
    
    def encode(self, long_url):
        id = self.counter
        self.counter += 1
        short = self.idToShortURL(id)
        self.url_map[short] = long_url
        return short
    
    def decode(self, short_url):
        return self.url_map.get(short_url, "")
    
    def idToShortURL(self, id):
        short = []
        while id > 0:
            short.append(self.alphabet[id % self.base])
            id = id // self.base
        return ''.join(reversed(short))
```
* **Key Details Interviewers Look For:**
  * Unique short URL generation
  * Efficient encoding and decoding
  * Scalability considerations (e.g., distributed systems, databases)
  * Handling collisions and redundancy
### 10.2 Design a Cache System (LRU Cache)<!-- {"fold":true} -->
* **Problem Statement:**
  * Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
* **Key Identifiers:**
  * Capacity limit
  * Operations: get and put
  * Evict least recently used item
* **Pseudocode:**
```
class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}
        self.order = DoublyLinkedList()
    
    def get(self, key):
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self.order.moveToFront(node)
        return node.value
    
    def put(self, key, value):
        if key in self.cache:
            node = self.cache[key]
            node.value = value
            self.order.moveToFront(node)
        else:
            if len(self.cache) == self.capacity:
                tail = self.order.popTail()
                del self.cache[tail.key]
            new_node = ListNode(key, value)
            self.order.addToFront(new_node)
            self.cache[key] = new_node
```
* **Key Details Interviewers Look For:**
  * Combination of hash map and doubly linked list for O(1) operations
  * Correctly updating usage order
  * Handling capacity limits and evictions

### 10.3 Design a Rate Limiter<!-- {"fold":true} -->
* **Problem Statement:**
  * Design a rate limiter that restricts the number of requests a user can make within a certain time window.
* **Key Identifiers:**
  * User identification
  * Time window and request limit
  * Efficient tracking and enforcement
* **Pseudocode:**
```
class RateLimiter:
    def __init__(self, max_requests, window_size):
        self.max_requests = max_requests
        self.window_size = window_size
        self.user_requests = {}
    
    def allowRequest(self, user_id, timestamp):
        if user_id not in self.user_requests:
            self.user_requests[user_id] = deque()
        requests = self.user_requests[user_id]
        while requests and timestamp - requests[0] > self.window_size:
            requests.popleft()
        if len(requests) < self.max_requests:
            requests.append(timestamp)
            return true
        return false
```
* **Key Details Interviewers Look For:**
  * Efficient data structures for tracking timestamps (e.g., deque)
  * Correctly sliding the time window
  * Handling multiple users and scalability

### 10.4 Design a Distributed System for Real-Time Chat<!-- {"fold":true} -->
* **Problem Statement:**
  * Design a real-time chat application that supports messaging between users with features like online presence and message history.
* **Key Identifiers:**
  * Real-time messaging
  * Online presence
  * Message history
  * Scalability and fault tolerance
* **Pseudocode:**
*Note: System design typically involves architectural diagrams and explanations rather than pseudocode. Below is a high-level approach.*

Components:
1. Load Balancer
2. Web Servers handling client connections (using WebSockets)
3. Message Broker (e.g., Kafka)
4. Chat Service handling message routing
5. Database for storing user data and message history (e.g., NoSQL)
6. Presence Service tracking online/offline status

Workflow:
	- Clients connect via WebSockets through Load Balancer to Web Servers
	- Messages are sent to Message Broker
	- Chat Service subscribes to Message Broker to route messages to recipients
	- Presence Service updates online status in real-time
	- Message history is stored in the database for retrieval
* **Key Details Interviewers Look For:**
  * Scalability across multiple servers
  * Handling real-time communication efficiently
  * Ensuring data consistency and fault tolerance
  * Security considerations (e.g., authentication, encryption)
### 10.5 Design a File System<!-- {"fold":true} -->
* **Problem Statement:**
  * Design a basic file system with directories and files, supporting operations like create, delete, and list.
* **Key Identifiers:**
  * Hierarchical directories and files
  * Operations: create, delete, list
  * Efficient storage and retrieval
* **Pseudocode:**
```
class FileSystem:
    def __init__():
        self.root = Directory("/")
    
    def createPath(path, value):
        parts = path.split('/')
        current = self.root
        for part in parts[1:-1]:
            if part not in current.children:
                return false
            current = current.children[part]
        new_part = parts[-1]
        if new_part in current.children:
            return false
        current.children[new_part] = File(new_part, value)
        return true
    
    def get(path):
        parts = path.split('/')
        current = self.root
        for part in parts[1:]:
            if part not in current.children:
                return -1
            current = current.children[part]
        return current.value if isinstance(current, File) else -1
```
* **Key Details Interviewers Look For:**
  * Hierarchical data structure implementation
  * Efficient path parsing and traversal
  * Handling of edge cases and errors
### 10.6 Design a Rate Limiter with Multiple Rate Limits<!-- {"fold":true} -->
* **Problem Statement:**
  * Design a rate limiter that can handle multiple rate limits (e.g., per second, per minute, per hour) for each user.
* **Key Identifiers:**
  * Multiple rate limits per user
  * Time windows of different sizes
  * Efficient tracking and enforcement
* **Pseudocode:**
```
class MultiRateLimiter:
    def __init__(self, rate_limits):
        # rate_limits: dict with key as window size and value as max requests
        self.rate_limits = rate_limits
        self.user_requests = {}
    
    def allowRequest(self, user_id, timestamp):
        if user_id not in self.user_requests:
            self.user_requests[user_id] = {window: deque() for window in self.rate_limits}
        for window, max_req in self.rate_limits.items():
            requests = self.user_requests[user_id][window]
            while requests and timestamp - requests[0] > window:
                requests.popleft()
            if len(requests) >= max_req:
                return false
        for window in self.rate_limits:
            self.user_requests[user_id][window].append(timestamp)
        return true
```
* **Key Details Interviewers Look For:**
  * Handling multiple queues for different windows
  * Efficiently managing sliding windows
  * Ensuring atomicity and thread-safety in distributed systems
### 10.7 Design a Notification System<!-- {"fold":true} -->
* **Problem Statement:**
  * Design a notification system that sends real-time alerts to users based on specific triggers.
* **Key Identifiers:**
  * Real-time notifications
  * Triggers based on events
  * Scalability and reliability
* **Pseudocode:**
*Note: System design involves architectural components rather than pseudocode.*

Components:
1. Event Producers generating events
2. Message Broker (e.g., Kafka, RabbitMQ) to handle event streaming
3. Notification Service processing events and sending notifications
4. User Preferences Service determining notification channels
5. Notification Channels (e.g., Email, SMS, Push)

Workflow:
	- Events are produced and sent to the Message Broker
	- Notification Service subscribes to relevant event streams
	- For each event, Notification Service checks user preferences
	- Sends notifications via the preferred channels
	- Ensures delivery and handles retries/failures
* **Key Details Interviewers Look For:**
  * Asynchronous processing of events
  * Handling high throughput and low latency
  * Ensuring reliability and fault tolerance

### 10.8 Design a Load Balancer<!-- {"fold":true} -->
* **Problem Statement:**
  * Design a load balancer that distributes incoming network traffic across multiple servers to ensure reliability and performance.
* **Key Identifiers:**
  * Distribute network traffic
  * Multiple backend servers
  * Ensure reliability and scalability
* **Pseudocode:**
*Note: System design involves architectural components rather than pseudocode.*

Components:
1. Client requests coming to the Load Balancer
2. Load Balancer with algorithms (e.g., Round Robin, Least Connections)
3. Backend Servers handling requests
4. Health Checker to monitor server health

Workflow:
	- Client sends request to Load Balancer
	- Load Balancer selects a healthy backend server based on the algorithm
	- Forward the request to the selected server
	- Health Checker periodically checks server statuses
	- Remove unhealthy servers from the rotation
* **Key Details Interviewers Look For:**
  * Different load balancing algorithms
  * Health monitoring of servers
  * Handling of server failures and traffic spikes
### 10.9 Design a Distributed Lock<!-- {"fold":true} -->
* **Problem Statement:**
  * Design a distributed lock system that ensures mutual exclusion across multiple nodes in a distributed environment.
* **Key Identifiers:**
  * Distributed environment
  * Mutual exclusion
  * Handle lock acquisition and release
* **Pseudocode:**
```
*class* DistributedLock:
    *de*f __init__(self, redis_client, lock_key, expiration):
        self.redis = redis_client
        self.lock_key = lock_key
        self.expiration = expiration
    
    *de*f acquire(self, identifier):
        return self.redis.set(self.lock_key, identifier, nx=True, ex=self.expiration)
    
    *de*f release(self, identifier):
        script = """
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
        """
        return self.redis.eval(script, 1, self.lock_key, identifier)
```
* **Key Details Interviewers Look For:**
  * Use of atomic operations (e.g., Redis SET with NX)
  * Ensuring lock ownership before release
  * Handling of expiration to prevent deadlocks

### 10.10 Design a Notification Queue<!-- {"fold":true} -->
* **Problem Statement:**
  * Design a notification queue system that handles high volumes of notifications with guaranteed delivery and scalability.
* **Key Identifiers:**
  * High volume notifications
  * Guaranteed delivery
  * Scalability and fault tolerance
* **Pseudocode:**
*Note: System design involves architectural components rather than pseudocode.*

Components:
1. Producers generating notifications
2. Message Queue (e.g., Kafka, RabbitMQ) to handle notification messages
3. Consumer Workers processing and sending notifications
4. Retry Mechanism for failed deliveries
5. Monitoring and Logging for system health

Workflow:
	- Producers send notification messages to the Message Queue
	- Consumer Workers subscribe to the queue and process messages
	- Upon successful sending, message is acknowledged and removed
	- Failed deliveries are retried based on retry policy
	- System scales by adding more workers as load increases
* **Key Details Interviewers Look For:**
  * Ensuring message durability and reliability
  * Handling retries and failures
  * Scaling consumers to match producer rate
# Conclusion<!-- {"fold":true} -->
----
## **Tips for Using This List:**
1. **Categorize Your Study:** Focus on one category at a time to build depth before breadth.
2. **Practice Coding:** Implement the pseudocode in your preferred programming language.
3. **Understand Concepts:** Beyond just solving, ensure you grasp the underlying principles.
4. **Optimize Solutions:** Strive for efficient time and space complexities.
5. **Mock Interviews:** Use these questions in timed settings to simulate real interview conditions.
